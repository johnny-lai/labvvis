
for_each(STORAGE, ACCESSOR, FUNCTOR)

STORAGE
+ IMPORTANT: Type cannot be marked as illife, unknown, aligned and unaligned at the same time.
	+ Same interface names help make it more difficult to accidentally do this?
	
+ contiguous_aligned_storage
	* Must be convertible to contiguous_unaligned_storage
	+ component_accessor -> component_tl
	+ iterator_type
	+ const_iterator_type
	+ begin()
	+ end()
	
+ contiguous_unaligned_storage
	* Must be convertible to contiguous_aligned_storage
	+ component_accessor -> component_tl
	+ iterator_type
	+ const_iterator_type
	+ begin()
	+ end()

+ unknown_storage
	+ component_accessor -> component_tl
	
+ Difference
	+
	
ITERATOR
+ contiguous_aligned_storage
	+ vector
	+ scalar
+ contiguous_unaligned_storage
	+ vector
	+ scalar
	
ACCESSOR
+ component_accessor
	+ Requires Iterator
		+ To return tuples

+ pixel_accessor
	+ Requires Iterator
		+ const scalar_type get_scalar() const
		+ void set_scalar(const scalar_type s)
		+ const vector_type get_vector() const
		+ const vector_type get_vector(const vvm::offset_t shift) cons
		+ void set_vector(const vector_type& v)

		
ALGORITHM
+ Different for aligned/unaligned
	+ Since both contiguous are convertible, up to algorithm to decide
	  which version to use, if both given.
		+ Probably use aligned if one aligned and one unaligned
			+ because aligned get loaded directly,
			+ unaligned still needs to be shifted anyway
			

STORAGE relationship
+ Important that
	+ Interface of contiguous supports unknown
		+ So can use unknown algorithm on
			+ unknown storage
			+ contiguous storage
	+ Interface of contiguous unaligned must support contiguous aligned
		+ So that can use contiguous aligned
			> unaligned_begin()	-> Returns iterator for unaligned
			> begin() -> Returns iterator for aligned access
	OR
	+ aligned storage interconvertible to unaligned storage
		+ To perform automatic conversions *if necessary*
			+ Algorithms accept
				storageT::aligned_storage
				OR
				storageT::unaligned_storage
			OR
			+ Algorithms accept
				aligned_storage<storageT>::type
				OR
				unaligned_storage<storageT>::type
			>> CHOOSE THIS because
				+ Can use in template metafunction
				+ Can implement if storageT is aligned, then return self
					+ User only has to specify the conversion for what it is not
		+ For each storageT, either aligned_storage or unaligned_storage is
		  the same as storageT
